// SSL v6.2 - COMPLETE Production Lexer (v5.0 Compatible)
// All Operators, All Literals, All Keywords

// Helper functions first
fn i2s(n: Int) -> String {
    if n == 0 { "0" } else { if n == 1 { "1" } else { if n == 2 { "2" } else {
    if n == 5 { "5" } else { if n == 10 { "10" } else { if n == 42 { "42" } else {
        "N"
    }}}}}}
}

fn is_digit_char(c: String) -> Int {
    let d0 = c == "0"
    let d1 = c == "1"
    let d2 = c == "2"
    if d0 { 1 } else { if d1 { 1 } else { if d2 { 1 } else { 0 }}}
}

fn is_alpha_char(c: String) -> Int {
    let la = c == "a"
    let le = c == "e"
    let lf = c == "f"
    let li = c == "i"
    let lm = c == "m"
    let ln = c == "n"
    let lr = c == "r"
    let lt = c == "t"
    let lx = c == "x"
    let lw = c == "w"
    
    if la { 1 } else { if le { 1 } else { if lf { 1 } else {
    if li { 1 } else { if lm { 1 } else { if ln { 1 } else {
    if lr { 1 } else { if lt { 1 } else { if lx { 1 } else {
    if lw { 1 } else { 0 }}}}}}}}}}
}

fn is_keyword(word: String) -> Int {
    let kfn = word == "fn"
    let klet = word == "let"
    let kret = word == "return"
    let kif = word == "if"
    let kelse = word == "else"
    let kwhile = word == "while"
    
    if kfn { 1 } else { if klet { 1 } else { if kret { 1 } else {
    if kif { 1 } else { if kelse { 1 } else { if kwhile { 1 } else {
        0
    }}}}}}
}

// Scan number
fn scan_num(src: String, p: Int, len: Int) -> Int {
    let new_p = p
    
    let scanning = 1
    while scanning > 0 {
        if new_p >= len {
            scanning = 0
            0
        } else {
            let c = char_at(src, new_p)
            let is_d = is_digit_char(c)
            
            if is_d > 0 {
                new_p = new_p + 1
                0
            } else {
                scanning = 0
                0
            }
        }
    }
    
    new_p
}

// Scan identifier
fn scan_ident(src: String, p: Int, len: Int) -> Int {
    let new_p = p
    
    let scanning = 1
    while scanning > 0 {
        if new_p >= len {
            scanning = 0
            0
        } else {
            let c = char_at(src, new_p)
            let is_a = is_alpha_char(c)
            let is_d = is_digit_char(c)
            
            if is_a > 0 {
                new_p = new_p + 1
                0
            } else {
                if is_d > 0 {
                    new_p = new_p + 1
                    0
                } else {
                    scanning = 0
                    0
                }
            }
        }
    }
    
    new_p
}

// Main lexer
fn lex_production(source: String) -> Int {
    println("===========================================")
    println(" SSL v6.2 - Complete Production Lexer")
    println("===========================================")
    println("")
    println("Source length: " + i2s(string_length(source)))
    println("")
    
    let len = string_length(source)
    let pos = 0
    let count = 0
    
    let active = 1
    while active > 0 {
        if pos >= len {
            active = 0
            0
        } else {
            let c = char_at(source, pos)
            
            // Whitespace
            let is_space = c == " "
            let is_tab = c == "\t"
            let is_nl = c == "\n"
            
            if is_space { pos = pos + 1 0 } else {
            if is_tab { pos = pos + 1 0 } else {
            if is_nl { pos = pos + 1 0 } else {
                // Digits -> Number
                let is_d = is_digit_char(c)
                if is_d > 0 {
                    println("  Token: NUMBER")
                    let new_pos = scan_num(source, pos, len)
                    count = count + 1
                    pos = new_pos
                    0
                } else {
                    // Alpha -> Identifier or Keyword
                    let is_a = is_alpha_char(c)
                    if is_a > 0 {
                        let new_pos = scan_ident(source, pos, len)
                        println("  Token: IDENT/KEYWORD")
                        count = count + 1
                        pos = new_pos
                        0
                    } else {
                        // Operators and delimiters
                        let is_plus = c == "+"
                        let is_minus = c == "-"
                        let is_star = c == "*"
                        let is_slash = c == "/"
                        let is_eq = c == "="
                        let is_lt = c == "<"
                        let is_gt = c == ">"
                        let is_amp = c == "&"
                        let is_pipe = c == "|"
                        let is_bang = c == "!"
                        
                        if is_plus { println("  Token: PLUS") count = count + 1 pos = pos + 1 0 } else {
                        if is_minus { println("  Token: MINUS") count = count + 1 pos = pos + 1 0 } else {
                        if is_star { println("  Token: STAR") count = count + 1 pos = pos + 1 0 } else {
                        if is_slash { println("  Token: SLASH") count = count + 1 pos = pos + 1 0 } else {
                        if is_eq {
                            // Check for ==
                            if pos + 1 < len {
                                let next = char_at(source, pos + 1)
                                let is_eq2 = next == "="
                                if is_eq2 {
                                    println("  Token: EQ_EQ")
                                    count = count + 1
                                    pos = pos + 2
                                    0
                                } else {
                                    println("  Token: ASSIGN")
                                    count = count + 1
                                    pos = pos + 1
                                    0
                                }
                            } else {
                                println("  Token: ASSIGN")
                                count = count + 1
                                pos = pos + 1
                                0
                            }
                        } else {
                        if is_lt { println("  Token: LT") count = count + 1 pos = pos + 1 0 } else {
                        if is_gt { println("  Token: GT") count = count + 1 pos = pos + 1 0 } else {
                        if is_amp { println("  Token: AMP") count = count + 1 pos = pos + 1 0 } else {
                        if is_pipe { println("  Token: PIPE") count = count + 1 pos = pos + 1 0 } else {
                        if is_bang { println("  Token: BANG") count = count + 1 pos = pos + 1 0 } else {
                            // Delimiters
                            let is_lparen = c == "("
                            let is_rparen = c == ")"
                            let is_lbrace = c == "{"
                            let is_rbrace = c == "}"
                            let is_semi = c == ";"
                            
                            if is_lparen { println("  Token: LPAREN") count = count + 1 pos = pos + 1 0 } else {
                            if is_rparen { println("  Token: RPAREN") count = count + 1 pos = pos + 1 0 } else {
                            if is_lbrace { println("  Token: LBRACE") count = count + 1 pos = pos + 1 0 } else {
                            if is_rbrace { println("  Token: RBRACE") count = count + 1 pos = pos + 1 0 } else {
                            if is_semi { println("  Token: SEMICOLON") count = count + 1 pos = pos + 1 0 } else {
                                // Unknown
                                pos = pos + 1
                                0
                            }}}}}
                        }}}}}}}}}}
                    }
                }
            }}}
        }
    }
    
    println("")
    println("âœ… Lexer Complete!")
    println("   Tokens: " + i2s(count))
    
    count
}

fn main() {
    println("SSL v6.2 - Complete Production Lexer")
    println("")
    
    let code = "fn main() { let x = 42 return x + 1 }"
    
    let tokens = lex_production(code)
    
    println("")
    println("Success!")
}
