// SSL 4.0 - Linear Types & Ownership Example
// Demonstrates Rust-inspired memory safety

import linear { Owned, Borrowed, LinearResource }

// Linear type - must be used exactly once
@linear
struct UniqueHandle {
    id: Int
}

impl UniqueHandle {
    fn new(id: Int) -> UniqueHandle {
        print("Handle ${id} created")
        UniqueHandle { id }
    }
    
    // Consumes self, returns new handle
    fn transfer(self) -> UniqueHandle {
        print("Handle ${self.id} transferred")
        self
    }
    
    // Consumes self, cannot be used after
    fn close(self) {
        print("Handle ${self.id} closed")
        // Handle is dropped here
    }
}

// Affine type - can be used at most once
@affine
struct Connection {
    socket: Socket
}

impl Connection {
    fn new(address: String) -> Connection {
        Connection { socket: Socket.connect(address) }
    }
    
    // Takes ownership of message
    fn send(self, message: owned String) -> Connection {
        self.socket.write(message)
        self  // Return self to continue using
    }
    
    fn close(self) {
        self.socket.close()
    }
}

// Borrowing examples
fn process_borrowed(data: &List<Int>) {
    // Can read data, but not modify or move it
    print("Length: ${data.length()}")
}

fn modify_borrowed(data: &mut List<Int>) {
    // Can modify, but not move
    data.push(42)
}

// Move semantics
fn take_ownership(data: owned String) {
    print("Took ownership of: ${data}")
    // data is dropped at end of function
}

// Resource that must be explicitly closed
@linear
struct File {
    path: String,
    handle: FileHandle
}

impl File {
    fn open(path: String) -> Result<File, IoError> {
        match native_open(path) {
            Ok(handle) => Ok(File { path, handle })
            Err(e) => Err(e)
        }
    }
    
    fn read(&self) -> String {
        native_read(self.handle)
    }
    
    fn write(&mut self, content: String) {
        native_write(self.handle, content)
    }
    
    // Must be called - compile error otherwise!
    fn close(self) {
        native_close(self.handle)
        print("File ${self.path} closed")
    }
}

fn main() {
    print("ðŸ”’ SSL Linear Types Demo")
    
    // Linear type usage
    let handle = UniqueHandle.new(1)
    let handle = handle.transfer()  // Must use return value
    handle.close()  // Must close - error if forgotten
    
    // This would be a compile error:
    // let h = UniqueHandle.new(2)
    // // h unused - compile error!
    
    // Borrowing
    let list = [1, 2, 3, 4, 5]
    
    process_borrowed(&list)  // Borrow immutably
    print("List still valid: ${list}")
    
    var mutable_list = [1, 2, 3]
    modify_borrowed(&mut mutable_list)  // Borrow mutably
    print("Modified list: ${mutable_list}")  // [1, 2, 3, 42]
    
    // Move semantics
    let message = "Hello, World!"
    take_ownership(message)  // message moved
    // print(message)  // Compile error: message was moved!
    
    // File resource
    let file = File.open("example.txt")?
    let content = file.read()
    print("Content: ${content}")
    file.close()  // Required! Compile error if omitted
    
    // Connection with affine semantics
    let conn = Connection.new("localhost:8080")
    let conn = conn.send("Hello")
    let conn = conn.send("World")
    conn.close()
    // Or just drop: conn goes out of scope
    
    print("\nLinear types provide:")
    print("  - Resource leak prevention")
    print("  - Memory safety without GC")
    print("  - Explicit ownership tracking")
    print("  - Zero-cost abstractions")
}
