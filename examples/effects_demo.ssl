// SSL 4.0 - Algebraic Effects Example
// Demonstrates Koka-inspired effect system

import effects { Effect, handle, perform }

// Define effects
effect Console {
    fn print(msg: String) -> Unit
    fn read() -> String
}

effect State<T> {
    fn get() -> T
    fn set(value: T) -> Unit
}

effect Error<E> {
    fn raise(error: E) -> Nothing
}

effect Async {
    fn await<T>(future: Future<T>) -> T
    fn spawn<T>(action: () -> T) -> Future<T>
}

// Function using Console effect
fn greet() with Console {
    perform Console.print("What is your name?")
    let name = perform Console.read()
    perform Console.print("Hello, ${name}!")
}

// Function using State effect
fn counter() with State<Int> {
    let current = perform State.get()
    perform State.set(current + 1)
    current + 1
}

// Function using Error effect
fn divide(a: Int, b: Int) with Error<String> -> Int {
    if b == 0 {
        perform Error.raise("Division by zero")
    }
    a / b
}

// Combining multiple effects
fn interactive_counter() with Console, State<Int> {
    perform Console.print("Current count: ${perform State.get()}")
    perform Console.print("Press enter to increment...")
    perform Console.read()
    perform State.set(perform State.get() + 1)
    perform Console.print("New count: ${perform State.get()}")
}

fn main() {
    print("âœ¨ SSL Algebraic Effects Demo")
    
    // Handle Console effect with actual I/O
    handle greet() with {
        Console.print(msg) => {
            native_print(msg)
            resume(())
        }
        Console.read() => {
            let input = native_readline()
            resume(input)
        }
    }
    
    // Handle State effect with mutable reference
    var state = 0
    let result = handle counter() with {
        State.get() => {
            resume(state)
        }
        State.set(value) => {
            state = value
            resume(())
        }
    }
    print("Counter result: ${result}")
    
    // Handle Error effect with Result
    let division = handle divide(10, 0) with {
        Error.raise(error) => {
            print("Error caught: ${error}")
            Result.Err(error)
        }
        return(value) => Result.Ok(value)
    }
    
    // Mock handler for testing
    handle greet() with {
        Console.print(msg) => {
            // Log instead of print
            log.info(msg)
            resume(())
        }
        Console.read() => {
            // Return mock input
            resume("Test User")
        }
    }
    
    print("\nEffects allow:")
    print("  - Explicit side effect tracking")
    print("  - Easy mocking for tests")
    print("  - Composable effect handlers")
    print("  - Type-safe effect polymorphism")
}
