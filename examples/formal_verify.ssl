// SSL 4.0 - Formal Verification Example
// Run with: ssl verify examples/formal_verify.ssl

import verify { Contract, requires, ensures, invariant }

// Function with pre/post conditions
@requires(n >= 0, "n must be non-negative")
@ensures(result >= 0, "factorial is always positive")
@ensures(n == 0 => result == 1, "factorial(0) = 1")
fn factorial(n: Int) -> Int {
    if n <= 1 {
        1
    } else {
        n * factorial(n - 1)
    }
}

// Binary search with verification
@requires(list.is_sorted(), "list must be sorted")
@requires(list.length() > 0, "list cannot be empty")
@ensures(result.is_none() || list[result.unwrap()] == target)
fn binary_search(list: List<Int>, target: Int) -> Option<Int> {
    var low = 0
    var high = list.length() - 1
    
    @invariant(low <= high + 1)
    @invariant(forall(0..low, |i| list[i] < target))
    @invariant(forall(high+1..list.length(), |i| list[i] > target))
    while low <= high {
        let mid = low + (high - low) / 2
        
        if list[mid] == target {
            return Some(mid)
        } else if list[mid] < target {
            low = mid + 1
        } else {
            high = mid - 1
        }
    }
    
    None
}

// Square root with contracts
@requires(x >= 0, "cannot take sqrt of negative")
@ensures(result >= 0, "sqrt is non-negative")
@ensures(abs(result * result - x) < 0.0001, "result squared equals input")
fn sqrt(x: Float) -> Float {
    if x == 0.0 {
        return 0.0
    }
    
    var guess = x / 2.0
    
    @invariant(guess > 0)
    for _ in 0..100 {
        let new_guess = (guess + x / guess) / 2.0
        if abs(new_guess - guess) < 0.0001 {
            return new_guess
        }
        guess = new_guess
    }
    
    guess
}

// Type state pattern with linear types
@linear
struct File {
    handle: FileHandle
}

impl File {
    @ensures(result.is_open())
    fn open(path: String) -> File {
        File { handle: native_open(path) }
    }
    
    @requires(self.is_open())
    @ensures(!self.is_open())
    fn close(self) {
        native_close(self.handle)
        // self is consumed - cannot use file after close
    }
    
    @requires(self.is_open())
    fn read(self) -> (File, String) {
        let content = native_read(self.handle)
        (self, content)
    }
}

fn main() {
    print("âœ“ SSL Formal Verification Demo")
    print("Run: ssl verify examples/formal_verify.ssl")
    
    // These will be verified at compile time
    let result = factorial(5)
    print("factorial(5) = ${result}")
    
    let list = [1, 3, 5, 7, 9, 11, 13]
    match binary_search(list, 7) {
        Some(index) => print("Found 7 at index ${index}")
        None => print("Not found")
    }
    
    let root = sqrt(16.0)
    print("sqrt(16) = ${root}")
    
    // Linear type usage - file must be closed
    let file = File.open("test.txt")
    let (file, content) = file.read()
    file.close()  // Required! Compile error if omitted
}
