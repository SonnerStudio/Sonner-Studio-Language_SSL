// SSL 3.0 - Functional Programming Demo
// Demonstrates: Pipe operator, function composition, auto-currying

// ============================================
// Helper Functions (Small, will be inlined)
// ============================================

fn double(x: Int) -> Int {
    return x * 2
}

fn square(x: Int) -> Int {
    return x * x
}

fn add_ten(x: Int) -> Int {
    return x + 10
}

fn add(a: Int, b: Int) -> Int {
    return a + b
}

// ============================================
// Pipe Operator Example
// ============================================

print("=== Pipe Operator ===")
print("")

// Without pipe: nested calls
let val1 = 5
let result_nested = square(double(add_ten(val1)))
print("Nested: square(double(add_ten(5))) = ")
print(result_nested)
// (5 + 10) * 2 = 30, 30^2 = 900

// With pipe: linear flow
let val2 = 5
let result_piped = val2 |> add_ten |> double |> square
print("Piped: 5 |> add_ten |> double |> square = ")
print(result_piped)
print("")

// ============================================
// Function Composition Example
// ============================================

print("=== Function Composition ===")
print("")

// Compose functions
let double_then_square = double >> square
let square_then_double = square >> double

let val3 = 3
let composed1 = double_then_square(val3)
print("double >> square (3) = ")
print(composed1)
// (3 * 2)^2 = 36

let composed2 = square_then_double(val3)
print("square >> double (3) = ")
print(composed2)
// (3^2) * 2 = 18
print("")

// ============================================
// Auto-Currying Example
// ============================================

print("=== Auto-Currying ===")
print("")

fn multiply(a: Int, b: Int, c: Int) -> Int {
    return a * b * c
}

// Auto-curry: provide fewer arguments
let multiply_by_2 = multiply(2)
let multiply_by_2_3 = multiply(2, 3)

let curry_result1 = multiply_by_2(5, 10)
print("multiply(2)(5, 10) = ")
print(curry_result1)
// 2 * 5 * 10 = 100

let curry_result2 = multiply_by_2_3(7)
print("multiply(2, 3)(7) = ")
print(curry_result2)
// 2 * 3 * 7 = 42
print("")

// ============================================
// Partial Application
// ============================================

print("=== Partial Application ===")
print("")

// Use auto-currying for partial application
let add_20 = add(20)

let vals = [1, 2, 3, 4, 5]
print("Adding 20 to each element manually:")

let r1 = add_20(vals[0])
let r2 = add_20(vals[1])
let r3 = add_20(vals[2])
let r4 = add_20(vals[3])
let r5 = add_20(vals[4])

print(r1)
print(r2)
print(r3)
print(r4)
print(r5)
print("")

// ============================================
// Complex Pipeline
// ============================================

print("=== Complex Pipeline ===")
print("")

fn process(x: Int) -> Int {
    return x |> add_ten |> double |> square |> add(100)
}

let complex_result = process(2)
print("process(2) = 2 |> add_ten |> double |> square |> add(100)")
print("Result: ")
print(complex_result)
// (2 + 10) * 2 = 24, 24^2 = 576, 576 + 100 = 676
print("")

// ============================================
// Validation
// ============================================

print("=== Validation ===")

if result_piped == 900 {
    if composed1 == 36 {
        if composed2 == 18 {
            if curry_result1 == 100 {
                if curry_result2 == 42 {
                    if complex_result == 676 {
                        print("✅ All tests passed!")
                        return 0
                    }
                }
            }
        }
    }
}

print("❌ Some tests failed")
return 1
