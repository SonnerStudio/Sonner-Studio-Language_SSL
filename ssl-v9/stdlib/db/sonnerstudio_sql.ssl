// SonnerStudio-SQL - Pure SSL Database Engine
// Features: JSON Storage, Vector Search, Time Travel

// Boolean constants (missing in parser/runtime)
let true = 1==1;
let false = 1==0;

// Nil constant
fn _make_nil() {}
let nil = _make_nil();

// Helper: Cosine Similarity for Vector Search
fn cosine_similarity(a: any, b: any) {
    if list_length(a) != list_length(b) {
        return 0;
    }
    
    let mut dot = 0;
    let mut norm_a = 0;
    let mut norm_b = 0;
    
    let len = list_length(a);
    let mut i = 0;
    
    while len > i {
        let val_a = a[i];
        let val_b = b[i];
        
        dot = dot + (val_a * val_b);
        norm_a = norm_a + (val_a * val_a);
        norm_b = norm_b + (val_b * val_b);
        
        i = i + 1;
    }
    
    if norm_a == 0 { return 0; }
    if norm_b == 0 { return 0; }
    
    return dot;
}

// Simple text split
fn split(s: string) {
    let mut res = [];
    let mut current = "";
    let len = string_length(s);
    let mut i = 0;
    while len > i {
        let c = string_get(s, i);
        if c == " " {
            if string_length(current) > 0 {
                res = list_append(res, current);
                current = "";
            }
        } else {
            current = current + c;
        }
        i = i + 1;
    }
    if string_length(current) > 0 {
        res = list_append(res, current);
    }
    return res;
}

// --- Core Database Functions ---

fn db_connect(path: string) {
    if fs_exists(path) == false {
        // init if needed
    }
    return {
        "path": path,
        "tables": {}
    };
}

fn db_create_table(db: any, name: string, schema: any) {
    let path = db["path"];
    let table_path = path + "/" + name + ".json";
    if fs_exists(table_path) {
        return "Table already exists";
    }
    
    let table_data = {
        "name": name,
        "schema": schema,
        "rows": []
    };
    
    let json = json_stringify(table_data);
    fs_write(table_path, json);
    return "Table created";
}

fn db_insert(db: any, table_name: string, row: any) {
    let path = db["path"];
    let table_path = path + "/" + table_name + ".json";
    
    if fs_exists(table_path) == false {
        return "Table not found";
    }
    
    let content = fs_read(table_path);
    let mut table_data = json_parse(content);
    
    let timestamp = 0;
    
    let entry = {
        "data": row,
        "_created": timestamp,
        "_active": true
    };
    
    let mut rows = table_data["rows"];
    rows = list_append(rows, entry);
    
    table_data = map_with(table_data, "rows", rows);
    
    fs_write(table_path, json_stringify(table_data));
    return "Inserted 1 row";
}

fn db_select(db: any, table_name: string, where_clause: any) {
    let path = db["path"];
    let table_path = path + "/" + table_name + ".json";
    if fs_exists(table_path) == false {
        return [];
    }
    
    let content = fs_read(table_path);
    let table_data = json_parse(content);
    let rows = table_data["rows"];
    let mut result = [];
    
    let len = list_length(rows);
    let mut i = 0;
    while len > i {
        let entry = rows[i];
        if entry["_active"] {
            let data = entry["data"];
            let mut include = true;
            
            if is_function(where_clause) {
                // Call it
                include = where_clause(data);
            }
            
            if include {
                result = list_append(result, data);
            }
        }
        i = i + 1;
    }
    
    return result;
}

fn db_vector_search(db: any, table_name: string, vector_col: string, query_vec: any, limit: int) {
     let path = db["path"];
     let table_path = path + "/" + table_name + ".json";
     if fs_exists(table_path) == false {
         return [];
     }
     
     let content = fs_read(table_path);
     let table_data = json_parse(content);
     let rows = table_data["rows"];
     
     let mut candidates = [];
     
     let len = list_length(rows);
     let mut i = 0;
     while len > i {
         let entry = rows[i];
         if entry["_active"] {
             let data = entry["data"];
             let vec = data[vector_col];
             
             let mut score = 0;
             if is_list(vec) {
                 if is_list(query_vec) {
                    let dim = list_length(vec);
                    let mut k = 0;
                    while dim > k {
                        score = score + (vec[k] * query_vec[k]);
                        k = k + 1;
                    }
                 }
             }
             
             let candidate = map_with(data, "_score", score);
             candidates = list_append(candidates, candidate);
         }
         i = i + 1;
     }
     
     // Top K
     let mut result = [];
     let mut k = 0;
     while limit > k {
         let mut max_score = 0 - 1; 
         let mut max_idx = 0 - 1;
         
         let cand_len = list_length(candidates);
         let mut j = 0;
         while cand_len > j {
             let c = candidates[j];
             if c != nil {
                 let s = c["_score"];
                 if s > max_score {
                     max_score = s;
                     max_idx = j;
                 }
             }
             j = j + 1;
         }
         
         if max_idx != (0 - 1) {
             result = list_append(result, candidates[max_idx]);
             candidates = list_with_index(candidates, max_idx, nil);
         } else {
             k = limit;
         }
         k = k + 1;
     }
     
     return result;
}

// Export functions via Map
let SQL = {
    "connect": db_connect,
    "create_table": db_create_table,
    "insert": db_insert,
    "select": db_select,
    "vector_search": db_vector_search
};
