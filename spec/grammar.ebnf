# SSL Grammar (EBNF)

## Sonner Studio Language v4.0 Grammar Specification

### Programs

```ebnf
program         = { declaration } ;
declaration     = function_decl
                | struct_decl
                | enum_decl
                | type_alias
                | import_decl
                | statement ;

### Declarations

function_decl   = { attribute } "fn" IDENTIFIER "(" [ parameters ] ")" [ "->" type ] block ;
attribute       = "@" IDENTIFIER [ "(" attribute_args ")" ] ;
attribute_args  = attribute_arg { "," attribute_arg } ;
attribute_arg   = IDENTIFIER ":" expression ;

struct_decl     = "struct" IDENTIFIER "{" { field_decl } "}" ;
field_decl      = IDENTIFIER ":" type ;

enum_decl       = "type" IDENTIFIER [ type_params ] "=" variant { "|" variant } ;
variant         = IDENTIFIER [ "(" type_list ")" ] ;

type_alias      = "type" IDENTIFIER "=" type ;

import_decl     = "import" module_path [ "{" import_list "}" ] ;
module_path     = IDENTIFIER { "." IDENTIFIER } ;
import_list     = IDENTIFIER { "," IDENTIFIER } ;

### Statements

statement       = let_stmt
                | var_stmt
                | assignment
                | expression_stmt
                | return_stmt
                | if_stmt
                | while_stmt
                | for_stmt
                | match_stmt
                | block ;

let_stmt        = "let" pattern [ ":" type ] "=" expression ;
var_stmt        = "var" IDENTIFIER [ ":" type ] "=" expression ;
assignment      = lvalue "=" expression ;
expression_stmt = expression ;
return_stmt     = "return" [ expression ] ;

if_stmt         = "if" expression block [ "else" ( if_stmt | block ) ] ;
while_stmt      = "while" expression block ;
for_stmt        = "for" pattern "in" expression block ;
match_stmt      = "match" expression "{" { match_arm } "}" ;
match_arm       = pattern [ "if" expression ] "=>" ( expression | block ) ;

block           = "{" { statement } "}" ;

### Expressions

expression      = or_expr ;
or_expr         = and_expr { "||" and_expr } ;
and_expr        = equality { "&&" equality } ;
equality        = comparison { ( "==" | "!=" ) comparison } ;
comparison      = term { ( "<" | "<=" | ">" | ">=" ) term } ;
term            = factor { ( "+" | "-" ) factor } ;
factor          = unary { ( "*" | "/" | "%" ) unary } ;
unary           = ( "!" | "-" ) unary | call ;
call            = primary { "(" [ arguments ] ")" | "." IDENTIFIER | "[" expression "]" } ;

primary         = IDENTIFIER
                | literal
                | "(" expression ")"
                | list_literal
                | map_literal
                | lambda
                | if_expr ;

lambda          = "|" [ parameters ] "|" ( expression | block ) ;
if_expr         = "if" expression block "else" block ;

### Patterns

pattern         = IDENTIFIER
                | literal
                | "_"
                | "(" pattern { "," pattern } ")"
                | IDENTIFIER "(" [ pattern { "," pattern } ] ")"
                | pattern "|" pattern ;

### Types

type            = simple_type
                | generic_type
                | function_type
                | tuple_type ;

simple_type     = "Int" | "Float" | "Bool" | "String" | "Char" | "Unit" | IDENTIFIER ;
generic_type    = IDENTIFIER "<" type { "," type } ">" ;
function_type   = "(" [ type { "," type } ] ")" "->" type ;
tuple_type      = "(" type { "," type } ")" ;

type_params     = "<" IDENTIFIER { "," IDENTIFIER } ">" ;

### v4.0 Extensions

effect_decl     = "effect" IDENTIFIER "{" { effect_op } "}" ;
effect_op       = "fn" IDENTIFIER "(" [ parameters ] ")" "->" type ;
with_clause     = "with" IDENTIFIER { "," IDENTIFIER } ;

linear_attr     = "@linear" | "@affine" ;
verify_attr     = "@requires" "(" STRING ")"
                | "@ensures" "(" STRING ")"
                | "@invariant" "(" STRING ")" ;

edge_attr       = "@edge" "(" { edge_param } ")" ;
edge_param      = IDENTIFIER ":" ( NUMBER | STRING | list_literal ) ;

property_attr   = "@property" [ "(" { property_param } ")" ] ;
property_param  = IDENTIFIER ":" ( NUMBER | IDENTIFIER ) ;

kernel_attr     = "@kernel" "(" "workgroup_size" ":" list_literal ")" ;

### Literals

literal         = NUMBER
                | STRING
                | CHAR
                | "true"
                | "false"
                | "nil" ;

list_literal    = "[" [ expression { "," expression } ] "]" ;
map_literal     = "{" [ map_entry { "," map_entry } ] "}" ;
map_entry       = ( IDENTIFIER | STRING ) ":" expression ;

### Lexical Elements

IDENTIFIER      = LETTER { LETTER | DIGIT | "_" } ;
NUMBER          = DIGIT { DIGIT } [ "." DIGIT { DIGIT } ] ;
STRING          = '"' { char } '"' ;
CHAR            = "'" char "'" ;

LETTER          = "a" ... "z" | "A" ... "Z" | "_" ;
DIGIT           = "0" ... "9" ;
```

---

## Reserved Keywords

```
fn struct type impl trait
let var if else match
for in while loop break continue return
true false nil
import as pub mod
async await try catch throw
effect with perform handle
```

## v4.0 Keywords

```
@property @edge @kernel @linear @affine
@requires @ensures @invariant
```

---

*SSL v4.0.0 Grammar - December 2024*
