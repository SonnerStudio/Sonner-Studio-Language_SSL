// SSL v8 Event System - GUI and async event handling

use core::Option;
use collections::Vec;
use collections::HashMap;

// Event types
pub enum Event {
    MouseMove { x: i64, y: i64 },
    MouseDown { x: i64, y: i64, button: MouseButton },
    MouseUp { x: i64, y: i64, button: MouseButton },
    KeyDown { key: KeyCode, modifiers: KeyModifiers },
    KeyUp { key: KeyCode, modifiers: KeyModifiers },
    WindowResize { width: i64, height: i64 },
    WindowClose,
    Timer { id: i64 },
    Custom { event_type: i64, data: i64 },
}

pub enum MouseButton {
    Left,
    Right,
    Middle,
}

pub struct KeyModifiers {
    pub shift: bool,
    pub ctrl: bool,
    pub alt: bool,
}

pub enum KeyCode {
    A, B, C, D, E, F, G, H, I, J, K, L, M,
    N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
    Num0, Num1, Num2, Num3, Num4, Num5, Num6, Num7, Num8, Num9,
    Space, Enter, Escape, Backspace, Tab,
    Left, Right, Up, Down,
}

// Event handler function type
pub type EventHandler = fn(Event) -> ();

// Event loop
pub struct EventLoop {
    handlers: HashMap<i64, Vec<EventHandler>>,
    running: bool,
    window_handle: i64,
}

impl EventLoop {
    pub fn new(window_handle: i64) -> EventLoop {
        EventLoop {
            handlers: HashMap::new(),
            running: false,
            window_handle,
        }
    }
    
    // Register event handler
    pub fn on(&mut self, event_type: i64, handler: EventHandler) {
        if let Option::Some(handlers) = self.handlers.get_mut(&event_type) {
            handlers.push(handler);
        } else {
            let mut handlers = Vec::new();
            handlers.push(handler);
            self.handlers.insert(event_type, handlers);
        }
    }
    
    // Start event loop
    pub fn run(&mut self) {
        self.running = true;
        
        while self.running {
            // Poll for events from OS
            let event_data = unsafe {
                platform_poll_event(self.window_handle)
            };
            
            if event_data.event_type == 0 {
                // No event, yield
                unsafe {
                    platform_yield();
                }
                continue;
            }
            
            // Parse event
            let event = self.parse_event(event_data);
            
            // Dispatch to handlers
            if let Option::Some(handlers) = self.handlers.get(&event_data.event_type) {
                for handler in handlers {
                    handler(event.clone());
                }
            }
            
            // Check for quit
            match event {
                Event::WindowClose => {
                    self.running = false;
                }
                _ => {}
            }
        }
    }
    
    // Stop event loop
    pub fn stop(&mut self) {
        self.running = false;
    }
    
    // Parse raw event data
    fn parse_event(&self, data: EventData) -> Event {
        match data.event_type {
            1 => Event::MouseMove {
                x: data.param1,
                y: data.param2,
            },
            2 => Event::MouseDown {
                x: data.param1,
                y: data.param2,
                button: self.parse_mouse_button(data.param3),
            },
            3 => Event::MouseUp {
                x: data.param1,
                y: data.param2,
                button: self.parse_mouse_button(data.param3),
            },
            4 => Event::KeyDown {
                key: self.parse_keycode(data.param1),
                modifiers: self.parse_modifiers(data.param2),
            },
            5 => Event::KeyUp {
                key: self.parse_keycode(data.param1),
                modifiers: self.parse_modifiers(data.param2),
            },
            6 => Event::WindowResize {
                width: data.param1,
                height: data.param2,
            },
            7 => Event::WindowClose,
            8 => Event::Timer { id: data.param1 },
            _ => Event::Custom {
                event_type: data.event_type,
                data: data.param1,
            },
        }
    }
    
    fn parse_mouse_button(&self, code: i64) -> MouseButton {
        match code {
            1 => MouseButton::Left,
            2 => MouseButton::Right,
            3 => MouseButton::Middle,
            _ => MouseButton::Left,
        }
    }
    
    fn parse_keycode(&self, code: i64) -> KeyCode {
        // Simplified - map virtual key codes
        match code {
            65 => KeyCode::A,
            // ... mapping for all keys
            _ => KeyCode::A,  // Fallback
        }
    }
    
    fn parse_modifiers(&self, flags: i64) -> KeyModifiers {
        KeyModifiers {
            shift: (flags & 1) != 0,
            ctrl: (flags & 2) != 0,
            alt: (flags & 4) != 0,
        }
    }
}

// Event data from platform
struct EventData {
    event_type: i64,
    param1: i64,
    param2: i64,
    param3: i64,
}

// Platform intrinsics
extern "intrinsic" {
    fn platform_poll_event(window_handle: i64) -> EventData;
    fn platform_yield();
}
