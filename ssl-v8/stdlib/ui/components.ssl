// SSL v8 UI Components Library
// Material Design components (Button, TextField, Label, Checkbox, Slider)

use ui::material::{MaterialColors, GlassmorphismStyle, Shadow, Animation, AnimationType};
use ui::Window;
use async::events::{Event, EventLoop};
use core::{String, Color};

// Base component trait
pub trait Component {
    fn render(&self, window: &Window);
    fn handle_event(&mut self, event: Event);
    fn get_id(&self) -> i64;
}

// Button component
pub struct Button {
    id: i64,
    x: i64,
    y: i64,
    width: i64,
    height: i64,
    text: String,
    color: Color,
    text_color: Color,
    on_click: Option<fn()>,
    style: ButtonStyle,
}

pub enum ButtonStyle {
    Filled,
    Outlined,
    Text,
}

impl Button {
    pub fn new(text: String, x: i64, y: i64) -> Button {
        Button {
            id: unsafe { platform_create_element() },
            x,
            y,
            width: 120,
            height: 40,
            text,
            color: Color::rgb(98, 0, 238),
            text_color: Color::rgb(255, 255, 255),
            on_click: Option::None,
            style: ButtonStyle::Filled,
        }
    }
    
    pub fn on_click(&mut self, handler: fn()) -> &mut Button {
        self.on_click = Option::Some(handler);
        self
    }
    
    pub fn set_style(&mut self, style: ButtonStyle) -> &mut Button {
        self.style = style;
        self
    }
}

impl Component for Button {
    fn render(&self, window: &Window) {
        unsafe {
            platform_render_button(
                window.handle,
                self.id,
                self.x, self.y,
                self.width, self.height,
                self.text.as_ptr(),
                self.color.r, self.color.g, self.color.b,
                self.text_color.r, self.text_color.g, self.text_color.b,
                self.style as i64
            );
        }
        
        let shadow = Shadow::default();
        shadow.apply(self.id);
    }
    
    fn handle_event(&mut self, event: Event) {
        match event {
            Event::MouseDown { x, y, .. } => {
                if x >= self.x && x <= self.x + self.width &&
                   y >= self.y && y <= self.y + self.height {
                    if let Option::Some(handler) = self.on_click {
                        handler();
                    }
                }
            }
            _ => {}
        }
    }
    
    fn get_id(&self) -> i64 { self.id }
}

// TextField component
pub struct TextField {
    id: i64,
    x: i64,
    y: i64,
    width: i64,
    height: i64,
    placeholder: String,
    value: String,
    focused: bool,
    on_change: Option<fn(String)>,
}

impl TextField {
    pub fn new(placeholder: String, x: i64, y: i64) -> TextField {
        TextField {
            id: unsafe { platform_create_element() },
            x,
            y,
            width: 200,
            height: 40,
            placeholder,
            value: String::new(),
            focused: false,
            on_change: Option::None,
        }
    }
    
    pub fn on_change(&mut self, handler: fn(String)) -> &mut TextField {
        self.on_change = Option::Some(handler);
        self
    }
    
    pub fn get_value(&self) -> &String {
        &self.value
    }
}

impl Component for TextField {
    fn render(&self, window: &Window) {
        unsafe {
            platform_render_textfield(
                window.handle,
                self.id,
                self.x, self.y,
                self.width, self.height,
                self.placeholder.as_ptr(),
                self.value.as_ptr(),
                if self.focused { 1 } else { 0 }
            );
        }
    }
    
    fn handle_event(&mut self, event: Event) {
        match event {
            Event::KeyDown { key, .. } => {
                if self.focused {
                    // Append character to value
                    // (simplified - real impl would handle all keys)
                    if let Option::Some(handler) = self.on_change {
                        handler(self.value.clone());
                    }
                }
            }
            _ => {}
        }
    }
    
    fn get_id(&self) -> i64 { self.id }
}

// Checkbox component
pub struct Checkbox {
    id: i64,
    x: i64,
    y: i64,
    label: String,
    checked: bool,
    on_toggle: Option<fn(bool)>,
}

impl Checkbox {
    pub fn new(label: String, x: i64, y: i64) -> Checkbox {
        Checkbox {
            id: unsafe { platform_create_element() },
            x,
            y,
            label,
            checked: false,
            on_toggle: Option::None,
        }
    }
    
    pub fn on_toggle(&mut self, handler: fn(bool)) -> &mut Checkbox {
        self.on_toggle = Option::Some(handler);
        self
    }
    
    pub fn is_checked(&self) -> bool {
        self.checked
    }
}

impl Component for Checkbox {
    fn render(&self, window: &Window) {
        unsafe {
            platform_render_checkbox(
                window.handle,
                self.id,
                self.x, self.y,
                self.label.as_ptr(),
                if self.checked { 1 } else { 0 }
            );
        }
    }
    
    fn handle_event(&mut self, event: Event) {
        match event {
            Event::MouseDown { x, y, .. } => {
                if x >= self.x && x <= self.x + 24 &&
                   y >= self.y && y <= self.y + 24 {
                    self.checked = !self.checked;
                    if let Option::Some(handler) = self.on_toggle {
                        handler(self.checked);
                    }
                }
            }
            _ => {}
        }
    }
    
    fn get_id(&self) -> i64 { self.id }
}

// Slider component
pub struct Slider {
    id: i64,
    x: i64,
    y: i64,
    width: i64,
    min: f32,
    max: f32,
    value: f32,
    on_change: Option<fn(f32)>,
}

impl Slider {
    pub fn new(min: f32, max: f32, x: i64, y: i64) -> Slider {
        Slider {
            id: unsafe { platform_create_element() },
            x,
            y,
            width: 200,
            min,
            max,
            value: min,
            on_change: Option::None,
        }
    }
    
    pub fn on_change(&mut self, handler: fn(f32)) -> &mut Slider {
        self.on_change = Option::Some(handler);
        self
    }
    
    pub fn get_value(&self) -> f32 {
        self.value
    }
}

impl Component for Slider {
    fn render(&self, window: &Window) {
        unsafe {
            platform_render_slider(
                window.handle,
                self.id,
                self.x, self.y,
                self.width,
                self.min, self.max, self.value
            );
        }
    }
    
    fn handle_event(&mut self, event: Event) {
        match event {
            Event::MouseMove { x, y } => {
                if x >= self.x && x <= self.x + self.width {
                    let percent = (x - self.x) as f32 / self.width as f32;
                    self.value = self.min + percent * (self.max - self.min);
                    
                    if let Option::Some(handler) = self.on_change {
                        handler(self.value);
                    }
                }
            }
            _ => {}
        }
    }
    
    fn get_id(&self) -> i64 { self.id }
}

// Label component
pub struct Label {
    id: i64,
    x: i64,
    y: i64,
    text: String,
    font_size: i64,
    color: Color,
}

impl Label {
    pub fn new(text: String, x: i64, y: i64) -> Label {
        Label {
            id: unsafe { platform_create_element() },
            x,
            y,
            text,
            font_size: 16,
            color: Color::rgb(0, 0, 0),
        }
    }
    
    pub fn set_font_size(&mut self, size: i64) -> &mut Label {
        self.font_size = size;
        self
    }
}

impl Component for Label {
    fn render(&self, window: &Window) {
        unsafe {
            platform_render_label(
                window.handle,
                self.id,
                self.x, self.y,
                self.text.as_ptr(),
                self.font_size,
                self.color.r, self.color.g, self.color.b
            );
        }
    }
    
    fn handle_event(&mut self, _event: Event) {}
    fn get_id(&self) -> i64 { self.id }
}

// Platform intrinsics
extern "intrinsic" {
    fn platform_create_element() -> i64;
    fn platform_render_button(
        window: i64, id: i64,
        x: i64, y: i64, w: i64, h: i64,
        text: *const u8,
        r: u8, g: u8, b: u8,
        tr: u8, tg: u8, tb: u8,
        style: i64
    );
    fn platform_render_textfield(
        window: i64, id: i64,
        x: i64, y: i64, w: i64, h: i64,
        placeholder: *const u8,
        value: *const u8,
        focused: i32
    );
    fn platform_render_checkbox(
        window: i64, id: i64,
        x: i64, y: i64,
        label: *const u8,
        checked: i32
    );
    fn platform_render_slider(
        window: i64, id: i64,
        x: i64, y: i64, width: i64,
        min: f32, max: f32, value: f32
    );
    fn platform_render_label(
        window: i64, id: i64,
        x: i64, y: i64,
        text: *const u8,
        font_size: i64,
        r: u8, g: u8, b: u8
    );
}
