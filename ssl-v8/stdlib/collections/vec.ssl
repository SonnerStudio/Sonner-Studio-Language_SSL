// SSL Standard Library - Collections Module
// Dynamic array implementation

struct Vec<T> {
    ptr: *mut T,
    len: usize,
    capacity: usize
}

impl<T> Vec<T> {
    // Creates a new, empty Vec
    fn new() -> Vec<T> {
        Vec {
            ptr: null_mut(),
            len: 0,
            capacity: 0
        }
    }
    
    // Creates a new Vec with the specified capacity
    fn with_capacity(capacity: usize) -> Vec<T> {
        if capacity == 0 {
            return Vec::new();
        }
        
        let ptr = unsafe {
            allocate(capacity * size_of::<T>()) as *mut T
        };
        
        Vec {
            ptr: ptr,
            len: 0,
            capacity: capacity
        }
    }
    
    // Returns the number of elements in the vector
    fn len(&self) -> usize {
        self.len
    }
    
    // Returns true if the vector contains no elements
    fn is_empty(&self) -> bool {
        self.len == 0
    }
    
    // Returns the number of elements the vector can hold without reallocating
    fn capacity(&self) -> usize {
        self.capacity
    }
    
    // Reserves capacity for at least additional more elements
    fn reserve(&mut self, additional: usize) {
        let required = self.len + additional;
        if required <= self.capacity {
            return;
        }
        
        let new_capacity = if self.capacity == 0 {
            if additional > 4 { additional } else { 4 }
        } else {
            let double = self.capacity * 2;
            if required > double { required } else { double }
        };
        
        self.realloc(new_capacity);
    }
    
    // Internal: Reallocate to new capacity
    fn realloc(&mut self, new_capacity: usize) {
        let new_ptr = unsafe {
            allocate(new_capacity * size_of::<T>()) as *mut T
        };
        
        if self.len > 0 {
            unsafe {
                copy_memory(self.ptr, new_ptr, self.len * size_of::<T>());
                deallocate(self.ptr as *mut u8);
            }
        }
        
        self.ptr = new_ptr;
        self.capacity = new_capacity;
    }
    
    // Appends an element to the back of the vector
    fn push(&mut self, value: T) {
        if self.len == self.capacity {
            self.reserve(1);
        }
        
        unsafe {
            let end = self.ptr.offset(self.len);
            *end = value;
        }
        
        self.len += 1;
    }
    
    // Removes the last element and returns it, or None if empty
    fn pop(&mut self) -> Option<T> {
        if self.len == 0 {
            return Option::None;
        }
        
        self.len -= 1;
        
        unsafe {
            let last = self.ptr.offset(self.len);
            return Option::Some(*last);
        }
    }
    
    // Returns a reference to an element at the given index
    fn get(&self, index: usize) -> Option<&T> {
        if index >= self.len {
            return Option::None;
        }
        
        unsafe {
            let elem = self.ptr.offset(index);
            return Option::Some(&*elem);
        }
    }
    
    // Returns a mutable reference to an element at the given index
    fn get_mut(&mut self, index: usize) -> Option<&mut T> {
        if index >= self.len {
            return Option::None;
        }
        
        unsafe {
            let elem = self.ptr.offset(index);
            return Option::Some(&mut *elem);
        }
    }
    
    // Inserts an element at position index
    fn insert(&mut self, index: usize, value: T) {
        if index > self.len {
            panic("index out of bounds");
        }
        
        if self.len == self.capacity {
            self.reserve(1);
        }
        
        unsafe {
            // Shift elements to the right
            if index < self.len {
                let src = self.ptr.offset(index);
                let dst = self.ptr.offset(index + 1);
                let count = self.len - index;
                copy_memory(src, dst, count * size_of::<T>());
            }
            
            // Insert new element
            let slot = self.ptr.offset(index);
            *slot = value;
        }
        
        self.len += 1;
    }
    
    // Removes and returns the element at position index
    fn remove(&mut self, index: usize) -> T {
        if index >= self.len {
            panic("index out of bounds");
        }
        
        unsafe {
            let elem = self.ptr.offset(index);
            let result = *elem;
            
            // Shift elements to the left
            if index < self.len - 1 {
                let src = self.ptr.offset(index + 1);
                let dst = self.ptr.offset(index);
                let count = self.len - index - 1;
                copy_memory(src, dst, count * size_of::<T>());
            }
            
            self.len -= 1;
            return result;
        }
    }
    
    // Clears the vector, removing all values
    fn clear(&mut self) {
        self.len = 0;
    }
    
    // Returns true if the vector contains an element equal to the given value
    fn contains(&self, value: &T) -> bool where T: Eq {
        for i in 0..self.len {
            if self[i] == *value {
                return true;
            }
        }
        return false;
    }
    
    // Reverses the order of elements in the vector
    fn reverse(&mut self) {
        if self.len <= 1 {
            return;
        }
        
        let mut i = 0;
        let mut j = self.len - 1;
        
        while i < j {
            unsafe {
                let a = self.ptr.offset(i);
                let b = self.ptr.offset(j);
                
                // Swap
                let temp = *a;
                *a = *b;
                *b = temp;
            }
            
            i += 1;
            j -= 1;
        }
    }
}

// Indexing support
impl<T> Index<usize> for Vec<T> {
    type Output = T;
    
    fn index(&self, index: usize) -> &T {
        if index >= self.len {
            panic("index out of bounds");
        }
        
        unsafe {
            let elem = self.ptr.offset(index);
            return &*elem;
        }
    }
}

impl<T> IndexMut<usize> for Vec<T> {
    fn index_mut(&mut self, index: usize) -> &mut T {
        if index >= self.len {
            panic("index out of bounds");
        }
        
        unsafe {
            let elem = self.ptr.offset(index);
            return &mut *elem;
        }
    }
}

// Drop implementation for cleanup
impl<T> Drop for Vec<T> {
    fn drop(&mut self) {
        if self.capacity > 0 {
            unsafe {
                deallocate(self.ptr as *mut u8);
            }
        }
    }
}

// Intrinsics (will be implemented by compiler)
extern "intrinsic" {
    fn allocate(size: usize) -> *mut u8;
    fn deallocate(ptr: *mut u8);
    fn copy_memory<T>(src: *const T, dst: *mut T, count: usize);
    fn size_of<T>() -> usize;
    fn null_mut<T>() -> *mut T;
}
