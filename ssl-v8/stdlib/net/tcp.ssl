// SSL v8 Networking - TCP/UDP Sockets and HTTP

use core::{String, Vec, Option, Result};
use async::future::{Future, Poll};

// TCP Socket
pub struct TcpSocket {
    handle: i64,
    connected: bool,
}

impl TcpSocket {
    pub fn connect(address: &String, port: u16) -> Result<TcpSocket, String> {
        let handle = unsafe {
            platform_tcp_connect(address.as_ptr(), port)
        };
        
        if handle < 0 {
            Result::Err("Failed to connect")
        } else {
            Result::Ok(TcpSocket { handle, connected: true })
        }
    }
    
    pub fn send(&self, data: &Vec<u8>) -> Result<usize, String> {
        let sent = unsafe {
            platform_tcp_send(self.handle, data.as_ptr(), data.len())
        };
        
        if sent < 0 {
            Result::Err("Send failed")
        } else {
            Result::Ok(sent as usize)
        }
    }
    
    pub fn receive(&self, buffer: &mut Vec<u8>) -> Result<usize, String> {
        let received = unsafe {
            platform_tcp_recv(self.handle, buffer.as_mut_ptr(), buffer.capacity())
        };
        
        if received < 0 {
            Result::Err("Receive failed")
        } else {
            Result::Ok(received as usize)
        }
    }
    
    pub fn close(&mut self) {
        if self.connected {
            unsafe {
                platform_tcp_close(self.handle);
            }
            self.connected = false;
        }
    }
}

// HTTP Client
pub struct HttpClient {
    timeout_ms: u64,
}

pub struct HttpRequest {
    pub method: HttpMethod,
    pub url: String,
    pub headers: Vec<(String, String)>,
    pub body: Option<Vec<u8>>,
}

pub enum HttpMethod {
    GET,
    POST,
    PUT,
    DELETE,
}

pub struct HttpResponse {
    pub status_code: u16,
    pub headers: Vec<(String, String)>,
    pub body: Vec<u8>,
}

impl HttpClient {
    pub fn new() -> HttpClient {
        HttpClient { timeout_ms: 30000 }
    }
    
    pub fn get(&self, url: String) -> Result<HttpResponse, String> {
        let request = HttpRequest {
            method: HttpMethod::GET,
            url,
            headers: Vec::new(),
            body: Option::None,
        };
        
        self.send(request)
    }
    
    pub fn post(&self, url: String, body: Vec<u8>) -> Result<HttpResponse, String> {
        let request = HttpRequest {
            method: HttpMethod::POST,
            url,
            headers: Vec::new(),
            body: Option::Some(body),
        };
        
        self.send(request)
    }
    
    fn send(&self, request: HttpRequest) -> Result<HttpResponse, String> {
        let response_code = unsafe {
            platform_http_request(
                request.method as i64,
                request.url.as_ptr(),
                if let Option::Some(body) = &request.body {
                    body.as_ptr()
                } else {
                    0 as *const u8
                },
                if let Option::Some(body) = &request.body {
                    body.len()
                } else {
                    0
                }
            )
        };
        
        if response_code < 0 {
            Result::Err("HTTP request failed")
        } else {
            Result::Ok(HttpResponse {
                status_code: response_code as u16,
                headers: Vec::new(),
                body: Vec::new(),
            })
        }
    }
}

extern "intrinsic" {
    fn platform_tcp_connect(address: *const u8, port: u16) -> i64;
    fn platform_tcp_send(handle: i64, data: *const u8, len: usize) -> i64;
    fn platform_tcp_recv(handle: i64, buffer: *mut u8, len: usize) -> i64;
    fn platform_tcp_close(handle: i64);
    fn platform_http_request(method: i64, url: *const u8, body: *const u8, body_len: usize) -> i64;
}
