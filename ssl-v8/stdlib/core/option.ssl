// SSL Standard Library - Core Module
// Fundamental types and operations

// Option type - represents an optional value
enum Option<T> {
    Some(T),
    None
}

impl<T> Option<T> {
    // Returns true if the option is a Some value
    fn is_some(&self) -> bool {
        match self {
            Option::Some(_) => true,
            Option::None => false
        }
    }
    
    // Returns true if the option is a None value
    fn is_none(&self) -> bool {
        match self {
            Option::Some(_) => false,
            Option::None => true
        }
    }
    
    // Unwraps the value, panicking if None
    fn unwrap(self) -> T {
        match self {
            Option::Some(val) => val,
            Option::None => panic("called `Option::unwrap()` on a `None` value")
        }
    }
    
    // Unwraps the value or returns a default
    fn unwrap_or(self, default: T) -> T {
        match self {
            Option::Some(val) => val,
            Option::None => default
        }
    }
    
    // Unwraps the value or computes it from a closure
    fn unwrap_or_else(self, f: fn() -> T) -> T {
        match self {
            Option::Some(val) => val,
            Option::None => f()
        }
    }
    
    // Maps an Option<T> to Option<U> by applying a function
    fn map<U>(self, f: fn(T) -> U) -> Option<U> {
        match self {
            Option::Some(val) => Option::Some(f(val)),
            Option::None => Option::None
        }
    }
    
    // Returns None if the option is None, otherwise calls f with the wrapped value
    fn and_then<U>(self, f: fn(T) -> Option<U>) -> Option<U> {
        match self {
            Option::Some(val) => f(val),
            Option::None => Option::None
        }
    }
    
    // Returns the option if it contains a value, otherwise returns optb
    fn or(self, optb: Option<T>) -> Option<T> {
        match self {
            Option::Some(_) => self,
            Option::None => optb
        }
    }
    
    // Converts from Option<T> to Option<&T>
    fn as_ref(&self) -> Option<&T> {
        match self {
            Option::Some(ref val) => Option::Some(val),
            Option::None => Option::None
        }
    }
}

// Result type - represents success or failure
enum Result<T, E> {
    Ok(T),
    Err(E)
}

impl<T, E> Result<T, E> {
    // Returns true if the result is Ok
    fn is_ok(&self) -> bool {
        match self {
            Result::Ok(_) => true,
            Result::Err(_) => false
        }
    }
    
    // Returns true if the result is Err
    fn is_err(&self) -> bool {
        match self {
            Result::Ok(_) => false,
            Result::Err(_) => true
        }
    }
    
    // Unwraps the Ok value, panicking if Err
    fn unwrap(self) -> T {
        match self {
            Result::Ok(val) => val,
            Result::Err(_) => panic("called `Result::unwrap()` on an `Err` value")
        }
    }
    
    // Unwraps the Err value, panicking if Ok
    fn unwrap_err(self) -> E {
        match self {
            Result::Ok(_) => panic("called `Result::unwrap_err()` on an `Ok` value"),
            Result::Err(err) => err
        }
    }
    
    // Unwraps the Ok value or returns a default
    fn unwrap_or(self, default: T) -> T {
        match self {
            Result::Ok(val) => val,
            Result::Err(_) => default
        }
    }
    
    // Maps a Result<T, E> to Result<U, E> by applying a function to Ok value
    fn map<U>(self, f: fn(T) -> U) -> Result<U, E> {
        match self {
            Result::Ok(val) => Result::Ok(f(val)),
            Result::Err(err) => Result::Err(err)
        }
    }
    
    // Maps a Result<T, E> to Result<T, F> by applying a function to Err value
    fn map_err<F>(self, f: fn(E) -> F) -> Result<T, F> {
        match self {
            Result::Ok(val) => Result::Ok(val),
            Result::Err(err) => Result::Err(f(err))
        }
    }
    
    // Calls f if the result is Ok, otherwise returns the Err value
    fn and_then<U>(self, f: fn(T) -> Result<U, E>) -> Result<U, E> {
        match self {
            Result::Ok(val) => f(val),
            Result::Err(err) => Result::Err(err)
        }
    }
    
    // Converts from Result<T, E> to Option<T>
    fn ok(self) -> Option<T> {
        match self {
            Result::Ok(val) => Option::Some(val),
            Result::Err(_) => Option::None
        }
    }
    
    // Converts from Result<T, E> to Option<E>
    fn err(self) -> Option<E> {
        match self {
            Result::Ok(_) => Option::None,
            Result::Err(err) => Option::Some(err)
        }
    }
}

// Convenience macro for early return on error
// Usage: let value = try!(result);
macro try($expr:expr) {
    match $expr {
        Result::Ok(val) => val,
        Result::Err(err) => return Result::Err(err)
    }
}

// Question mark operator alternative
// Usage: let value = result?;
// (Will be implemented as syntax sugar later)
