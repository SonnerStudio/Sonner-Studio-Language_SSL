// SSL v8 String Type - UTF-8 String implementation

use core::Option;
use core::Result;
use collections::Vec;

pub struct String {
    bytes: Vec<u8>,
    length: usize,  // Number of UTF-8 characters (not bytes)
}

impl String {
    // Create new empty string
    pub fn new() -> String {
        String {
            bytes: Vec::new(),
            length: 0,
        }
    }
    
    // Create from string literal
    pub fn from(literal: &str) -> String {
        let mut bytes = Vec::new();
        let mut length = 0;
        
        for byte in literal.bytes() {
            bytes.push(byte);
            // Count UTF-8 characters (start bytes)
            if (byte & 0xC0) != 0x80 {
                length += 1;
            }
        }
        
        String { bytes, length }
    }
    
    // Get length in characters
    pub fn len(&self) -> usize {
        self.length
    }
    
    // Get length in bytes
    pub fn byte_len(&self) -> usize {
        self.bytes.len()
    }
    
    // Check if empty
    pub fn is_empty(&self) -> bool {
        self.length == 0
    }
    
    // Get byte at index
    pub fn byte_at(&self, index: usize) -> Option<u8> {
        if index < self.bytes.len() {
            Option::Some(self.bytes[index])
        } else {
            Option::None
        }
    }
    
    // Append string
    pub fn push_str(&mut self, other: &String) {
        for i in 0..other.bytes.len() {
            self.bytes.push(other.bytes[i]);
        }
        self.length += other.length;
    }
    
    // Append single character (UTF-8)
    pub fn push(&mut self, ch: char) {
        let code_point = ch as u32;
        
        if code_point < 0x80 {
            // 1-byte UTF-8
            self.bytes.push(code_point as u8);
        } else if code_point < 0x800 {
            // 2-byte UTF-8
            self.bytes.push((0xC0 | (code_point >> 6)) as u8);
            self.bytes.push((0x80 | (code_point & 0x3F)) as u8);
        } else if code_point < 0x10000 {
            // 3-byte UTF-8
            self.bytes.push((0xE0 | (code_point >> 12)) as u8);
            self.bytes.push((0x80 | ((code_point >> 6) & 0x3F)) as u8);
            self.bytes.push((0x80 | (code_point & 0x3F)) as u8);
        } else {
            // 4-byte UTF-8
            self.bytes.push((0xF0 | (code_point >> 18)) as u8);
            self.bytes.push((0x80 | ((code_point >> 12) & 0x3F)) as u8);
            self.bytes.push((0x80 | ((code_point >> 6) & 0x3F)) as u8);
            self.bytes.push((0x80 | (code_point & 0x3F)) as u8);
        }
        
        self.length += 1;
    }
    
    // Trim whitespace
    pub fn trim(&self) -> String {
        let mut start = 0;
        let mut end = self.bytes.len();
        
        // Trim start
        while start < end && self.is_whitespace(self.bytes[start]) {
            start += 1;
        }
        
        // Trim end
        while end > start && self.is_whitespace(self.bytes[end - 1]) {
            end -= 1;
        }
        
        let mut result = String::new();
        for i in start..end {
            result.bytes.push(self.bytes[i]);
        }
        result.length = self.count_chars(&result.bytes);
        result
    }
    
    // Split by delimiter
    pub fn split(&self, delimiter: char) -> Vec<String> {
        let mut result = Vec::new();
        let mut current = String::new();
        
        let delim_byte = delimiter as u8;
        
        for i in 0..self.bytes.len() {
            if self.bytes[i] == delim_byte {
                if !current.is_empty() {
                    result.push(current);
                    current = String::new();
                }
            } else {
                current.bytes.push(self.bytes[i]);
            }
        }
        
        if !current.is_empty() {
            current.length = self.count_chars(&current.bytes);
            result.push(current);
        }
        
        result
    }
    
    // Check if starts with prefix
    pub fn starts_with(&self, prefix: &String) -> bool {
        if prefix.bytes.len() > self.bytes.len() {
            return false;
        }
        
        for i in 0..prefix.bytes.len() {
            if self.bytes[i] != prefix.bytes[i] {
                return false;
            }
        }
        
        true
    }
    
    // Check if ends with suffix
    pub fn ends_with(&self, suffix: &String) -> bool {
        if suffix.bytes.len() > self.bytes.len() {
            return false;
        }
        
        let offset = self.bytes.len() - suffix.bytes.len();
        for i in 0..suffix.bytes.len() {
            if self.bytes[offset + i] != suffix.bytes[i] {
                return false;
            }
        }
        
        true
    }
    
    // Convert to uppercase (ASCII only for now)
    pub fn to_uppercase(&self) -> String {
        let mut result = String::new();
        
        for i in 0..self.bytes.len() {
            let byte = self.bytes[i];
            if byte >= 97 && byte <= 122 {  // a-z
                result.bytes.push(byte - 32);
            } else {
                result.bytes.push(byte);
            }
        }
        
        result.length = self.length;
        result
    }
    
    // Convert to lowercase (ASCII only for now)
    pub fn to_lowercase(&self) -> String {
        let mut result = String::new();
        
        for i in 0..self.bytes.len() {
            let byte = self.bytes[i];
            if byte >= 65 && byte <= 90 {  // A-Z
                result.bytes.push(byte + 32);
            } else {
                result.bytes.push(byte);
            }
        }
        
        result.length = self.length;
        result
    }
    
    // Helper: check if byte is whitespace
    fn is_whitespace(&self, byte: u8) -> bool {
        byte == 32 || byte == 9 || byte == 10 || byte == 13  // space, tab, LF, CR
    }
    
    // Helper: count UTF-8 characters
    fn count_chars(&self, bytes: &Vec<u8>) -> usize {
        let mut count = 0;
        for i in 0..bytes.len() {
            if (bytes[i] & 0xC0) != 0x80 {
                count += 1;
            }
        }
        count
    }
    
    // Get raw byte pointer (for C interop)
    pub fn as_ptr(&self) -> *const u8 {
        self.bytes.as_ptr()
    }
}

// StringBuilder - efficient string construction
pub struct StringBuilder {
    buffer: Vec<u8>,
    capacity: usize,
}

impl StringBuilder {
    pub fn new() -> StringBuilder {
        StringBuilder::with_capacity(64)
    }
    
    pub fn with_capacity(capacity: usize) -> StringBuilder {
        StringBuilder {
            buffer: Vec::with_capacity(capacity),
            capacity,
        }
    }
    
    pub fn append(&mut self, s: &String) {
        for i in 0..s.bytes.len() {
            self.buffer.push(s.bytes[i]);
        }
    }
    
    pub fn append_char(&mut self, ch: char) {
        let mut temp = String::new();
        temp.push(ch);
        self.append(&temp);
    }
    
    pub fn append_str(&mut self, literal: &str) {
        let s = String::from(literal);
        self.append(&s);
    }
    
    pub fn to_string(&self) -> String {
        let mut result = String::new();
        result.bytes = self.buffer.clone();
        result.length = result.count_chars(&result.bytes);
        result
    }
    
    pub fn clear(&mut self) {
        self.buffer.clear();
    }
}

// Format helper (basic sprintf-like)
pub fn format(template: &str, args: Vec<String>) -> String {
    let mut result = StringBuilder::new();
    let template_str = String::from(template);
    let mut arg_index = 0;
    
    let mut i = 0;
    while i < template_str.bytes.len() {
        if template_str.bytes[i] == '{' as u8 && i + 1 < template_str.bytes.len() {
            if template_str.bytes[i + 1] == '}' as u8 {
                // {} placeholder
                if arg_index < args.len() {
                    result.append(&args[arg_index]);
                    arg_index += 1;
                }
                i += 2;
                continue;
            }
        }
        
        result.buffer.push(template_str.bytes[i]);
        i += 1;
    }
    
    result.to_string()
}
