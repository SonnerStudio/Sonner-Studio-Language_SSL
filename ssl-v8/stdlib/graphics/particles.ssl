// SSL v8 Particle Systems - Special Effects

use core::{Vec, Option};
use graphics::scene3d::{Vector3, Color};

// Particle
pub struct Particle {
    pub position: Vector3,
    pub velocity: Vector3,
    pub acceleration: Vector3,
    pub color: Color,
    pub size: f32,
    pub lifetime: f32,
    pub age: f32,
}

impl Particle {
    pub fn new(position: Vector3) -> Particle {
        Particle {
            position,
            velocity: Vector3::zero(),
            acceleration: Vector3::new(0.0, -9.81, 0.0),  // Gravity
            color: Color { r: 1.0, g: 1.0, b: 1.0, a: 1.0 },
            size: 1.0,
            lifetime: 5.0,
            age: 0.0,
        }
    }
    
    pub fn update(&mut self, delta_time: f32) {
        self.velocity.x += self.acceleration.x * delta_time;
        self.velocity.y += self.acceleration.y * delta_time;
        self.velocity.z += self.acceleration.z * delta_time;
        
        self.position.x += self.velocity.x * delta_time;
        self.position.y += self.velocity.y * delta_time;
        self.position.z += self.velocity.z * delta_time;
        
        self.age += delta_time;
    }
    
    pub fn is_alive(&self) -> bool {
        self.age < self.lifetime
    }
}

// Particle Emitter
pub struct ParticleEmitter {
    particles: Vec<Particle>,
    max_particles: usize,
    emission_rate: f32,
    emission_timer: f32,
    position: Vector3,
    emitter_type: EmitterType,
}

pub enum EmitterType {
    Point,
    Sphere { radius: f32 },
    Box { size: Vector3 },
    Cone { radius: f32, angle: f32 },
}

impl ParticleEmitter {
    pub fn new(position: Vector3, max_particles: usize) -> ParticleEmitter {
        ParticleEmitter {
            particles: Vec::new(),
            max_particles,
            emission_rate: 10.0,  // particles per second
            emission_timer: 0.0,
            position,
            emitter_type: EmitterType::Point,
        }
    }
    
    pub fn update(&mut self, delta_time: f32) {
        // Emit new particles
        self.emission_timer += delta_time;
        let particles_to_emit = (self.emission_timer * self.emission_rate) as usize;
        
        for _ in 0..particles_to_emit {
            if self.particles.len() < self.max_particles {
                self.emit_particle();
            }
        }
        
        self.emission_timer = 0.0;
        
        // Update existing particles
        let mut i = 0;
        while i < self.particles.len() {
            self.particles[i].update(delta_time);
            
            if !self.particles[i].is_alive() {
                self.particles.remove(i);
            } else {
                i += 1;
            }
        }
    }
    
    fn emit_particle(&mut self) {
        let mut particle = Particle::new(self.position);
        
        // Set initial velocity based on emitter type
        match self.emitter_type {
            EmitterType::Point => {
                let angle_xz = random_float() * 2.0 * 3.14159;
                let angle_y = (random_float() - 0.5) * 3.14159;
                let speed = 5.0;
                
                particle.velocity = Vector3::new(
                    angle_xz.cos() * angle_y.cos() * speed,
                    angle_y.sin() * speed,
                    angle_xz.sin() * angle_y.cos() * speed
                );
            }
            _ => {}
        }
        
        self.particles.push(particle);
    }
    
    pub fn render(&self) {
        unsafe {
            platform_begin_particles();
            
            for particle in &self.particles {
                platform_render_particle(
                    particle.position.x,
                    particle.position.y,
                    particle.position.z,
                    particle.size,
                    particle.color.r,
                    particle.color.g,
                    particle.color.b,
                    particle.color.a
                );
            }
            
            platform_end_particles();
        }
    }
}

// Preset Effects
pub fn create_fire_emitter(position: Vector3) -> ParticleEmitter {
    let mut emitter = ParticleEmitter::new(position, 1000);
    emitter.emission_rate = 50.0;
    emitter
}

pub fn create_smoke_emitter(position: Vector3) -> ParticleEmitter {
    let mut emitter = ParticleEmitter::new(position, 500);
    emitter.emission_rate = 20.0;
    emitter
}

pub fn create_explosion(position: Vector3) -> ParticleEmitter {
    let mut emitter = ParticleEmitter::new(position, 2000);
    emitter.emission_rate = 500.0;
    emitter
}

pub fn create_rain(position: Vector3, width: f32, depth: f32) -> ParticleEmitter {
    let mut emitter = ParticleEmitter::new(position, 5000);
    emitter.emission_rate = 100.0;
    emitter.emitter_type = EmitterType::Box {
        size: Vector3::new(width, 0.1, depth)
    };
    emitter
}

fn random_float() -> f32 {
    unsafe { platform_random_float() }
}

// Platform intrinsics
extern "intrinsic" {
    fn platform_begin_particles();
    fn platform_end_particles();
    fn platform_render_particle(x: f32, y: f32, z: f32, size: f32, r: f32, g: f32, b: f32, a: f32);
    fn platform_random_float() -> f32;
}
