// SSL Standard Library - I/O Module
// Input/Output operations

use core::Result;

struct File {
    handle: i64,
    path: String
}

impl File {
    // Opens a file in read-only mode
    fn open(path: String) -> Result<File, String> {
        let handle = unsafe { file_open(path.as_ptr(), 0) };  // 0 = read mode
        
        if handle < 0 {
            return Result::Err("Failed to open file");
        }
        
        return Result::Ok(File {
            handle: handle,
            path: path
        });
    }
    
    // Creates a new file for writing
    fn create(path: String) -> Result<File, String> {
        let handle = unsafe { file_open(path.as_ptr(), 1) };  // 1 = write mode
        
        if handle < 0 {
            return Result::Err("Failed to create file");
        }
        
        return Result::Ok(File {
            handle: handle,
            path: path
        });
    }
    
    // Reads the entire file to a string
    fn read_to_string(&self) -> Result<String, String> {
        let size = unsafe { file_size(self.handle) };
        
        if size < 0 {
            return Result::Err("Failed to get file size");
        }
        
        let buffer = unsafe { allocate(size as usize) };
        let bytes_read = unsafe { file_read(self.handle, buffer, size) };
        
        if bytes_read != size {
            unsafe { deallocate(buffer); }
            return Result::Err("Failed to read file");
        }
        
        // Convert bytes to string
        let result = String::from_raw_parts(buffer, size as usize);
        return Result::Ok(result);
    }
    
    // Writes a string to the file
    fn write(&mut self, content: String) -> Result<(), String> {
        let bytes_written = unsafe {
            file_write(self.handle, content.as_ptr(), content.len() as i64)
        };
        
        if bytes_written != content.len() as i64 {
            return Result::Err("Failed to write file");
        }
        
        return Result::Ok(());
    }
}

impl Drop for File {
    fn drop(&mut self) {
        unsafe {
            file_close(self.handle);
        }
    }
}

// Standard output functions
fn print(message: String) {
    unsafe {
        stdout_write(message.as_ptr(), message.len() as i64);
    }
}

fn println(message: String) {
    print(message);
    print("\n");
}

// Standard input function
fn read_line() -> Result<String, String> {
    let buffer = unsafe { allocate(1024) };  // 1KB buffer
    let bytes_read = unsafe { stdin_read(buffer, 1024) };
    
    if bytes_read < 0 {
        unsafe { deallocate(buffer); }
        return Result::Err("Failed to read from stdin");
    }
    
    let result = String::from_raw_parts(buffer, bytes_read as usize);
    return Result::Ok(result);
}

// File system intrinsics (platform-specific, implemented by runtime)
extern "intrinsic" {
    fn file_open(path: *const u8, mode: i32) -> i64;
    fn file_close(handle: i64);
    fn file_read(handle: i64, buffer: *mut u8, size: i64) -> i64;
    fn file_write(handle: i64, buffer: *const u8, size: i64) -> i64;
    fn file_size(handle: i64) -> i64;
    fn stdout_write(buffer: *const u8, size: i64);
    fn stdin_read(buffer: *mut u8, size: i64) -> i64;
    fn allocate(size: usize) -> *mut u8;
    fn deallocate(ptr: *mut u8);
}
