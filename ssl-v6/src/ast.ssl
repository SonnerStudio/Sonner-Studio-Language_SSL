// SSL v6.0 - AST (Abstract Syntax Tree) Definitions
// Data structures for representing parsed code

// Expression Types
fn expr_int(value: Int) -> Any {
    ["INT", value]
}

fn expr_float(value: Float) -> Any {
    ["FLOAT", value]
}

fn expr_string(value: String) -> Any {
    ["STRING", value]
}

fn expr_bool(value: Int) -> Any {
    ["BOOL", value]
}

fn expr_ident(name: String) -> Any {
    ["IDENT", name]
}

fn expr_binary(left: Any, op: String, right: Any) -> Any {
    ["BINARY", left, op, right]
}

fn expr_unary(op: String, operand: Any) -> Any {
    ["UNARY", op, operand]
}

fn expr_call(func: Any, args: Any) -> Any {
    ["CALL", func, args]
}

fn expr_if(cond: Any, then_branch: Any, else_branch: Any) -> Any {
    ["IF", cond, then_branch, else_branch]
}

fn expr_while(cond: Any, body: Any) -> Any {
    ["WHILE", cond, body]
}

fn expr_block(stmts: Any) -> Any {
    ["BLOCK", stmts]
}

fn expr_match(value: Any, arms: Any) -> Any {
    ["MATCH", value, arms]
}

// Statement Types
fn stmt_let(name: String, type_ann: Any, init: Any) -> Any {
    ["LET", name, type_ann, init]
}

fn stmt_var(name: String, type_ann: Any, init: Any) -> Any {
    ["VAR", name, type_ann, init]
}

fn stmt_assign(target: Any, value: Any) -> Any {
    ["ASSIGN", target, value]
}

fn stmt_return(value: Any) -> Any {
    ["RETURN", value]
}

fn stmt_expr(expr: Any) -> Any {
    ["EXPR_STMT", expr]
}

// Function Definition
fn decl_function(name: String, params: Any, ret_type: Any, body: Any) -> Any {
    ["FUNCTION", name, params, ret_type, body]
}

fn param(name: String, type_ann: Any) -> Any {
    ["PARAM", name, type_ann]
}

// Type Annotations
fn type_simple(name: String) -> Any {
    ["TYPE", name]
}

fn type_function(param_types: Any, ret_type: Any) -> Any {
    ["FUNC_TYPE", param_types, ret_type]
}

// Program (top-level)
fn program(decls: Any) -> Any {
    ["PROGRAM", decls]
}

// AST Utilities
fn ast_tag(node: Any) -> String {
    if is_list(node) > 0 {
        node[0]
    } else {
        "UNKNOWN"
    }
}

fn is_expr(node: Any) -> Int {
    let tag = ast_tag(node)
    if tag == "INT" { 1 } else {
    if tag == "FLOAT" { 1 } else {
    if tag == "STRING" { 1 } else {
    if tag == "BOOL" { 1 } else {
    if tag == "IDENT" { 1 } else {
    if tag == "BINARY" { 1 } else {
    if tag == "UNARY" { 1 } else {
    if tag == "CALL" { 1 } else {
    if tag == "IF" { 1 } else {
    if tag == "WHILE" { 1 } else {
    if tag == "BLOCK" { 1 } else {
    if tag == "MATCH" { 1 } else {
        0
    }}}}}}}}}}}}
}

fn is_stmt(node: Any) -> Int {
    let tag = ast_tag(node)
    if tag == "LET" { 1 } else {
    if tag == "VAR" { 1 } else {
    if tag == "ASSIGN" { 1 } else {
    if tag == "RETURN" { 1 } else {
    if tag == "EXPR_STMT" { 1 } else {
        0
    }}}}}
}

// Helper
fn is_list(x: Any) -> Int {
    0  // Builtin check
}
